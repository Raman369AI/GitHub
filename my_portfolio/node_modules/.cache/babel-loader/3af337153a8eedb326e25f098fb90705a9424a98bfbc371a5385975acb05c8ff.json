{"ast":null,"code":"import { correctNodes } from './utils/correctFocus';\nimport { pickFocusable } from './utils/firstFocus';\nimport { isGuard } from './utils/is';\nexport var NEW_FOCUS = 'NEW_FOCUS';\n/**\n * Main solver for the \"find next focus\" question\n * @param innerNodes - used to control \"return focus\"\n * @param innerTabbables - used to control \"autofocus\"\n * @param outerNodes\n * @param activeElement\n * @param lastNode\n * @returns {number|string|undefined|*}\n */\nexport var newFocus = function (innerNodes, innerTabbables, outerNodes, activeElement, lastNode) {\n  var cnt = innerNodes.length;\n  var firstFocus = innerNodes[0];\n  var lastFocus = innerNodes[cnt - 1];\n  var isOnGuard = isGuard(activeElement);\n  // focus is inside\n  if (activeElement && innerNodes.indexOf(activeElement) >= 0) {\n    return undefined;\n  }\n  var activeIndex = activeElement !== undefined ? outerNodes.indexOf(activeElement) : -1;\n  var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;\n  var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;\n  // no active focus (or focus is on the body)\n  if (activeIndex === -1) {\n    // known fallback\n    if (lastNodeInside !== -1) {\n      return lastNodeInside;\n    }\n    return NEW_FOCUS;\n  }\n  // new focus, nothing to calculate\n  if (lastNodeInside === -1) {\n    return NEW_FOCUS;\n  }\n  var indexDiff = activeIndex - lastIndex;\n  var firstNodeIndex = outerNodes.indexOf(firstFocus);\n  var lastNodeIndex = outerNodes.indexOf(lastFocus);\n  var correctedNodes = correctNodes(outerNodes);\n  var currentFocusableIndex = activeElement !== undefined ? correctedNodes.indexOf(activeElement) : -1;\n  var previousFocusableIndex = lastNode ? correctedNodes.indexOf(lastNode) : currentFocusableIndex;\n  var tabbableNodes = correctedNodes.filter(function (node) {\n    return node.tabIndex >= 0;\n  });\n  var currentTabbableIndex = activeElement !== undefined ? tabbableNodes.indexOf(activeElement) : -1;\n  var previousTabbableIndex = lastNode ? tabbableNodes.indexOf(lastNode) : currentTabbableIndex;\n  var focusIndexDiff = currentTabbableIndex >= 0 && previousTabbableIndex >= 0 ?\n  // old/new are tabbables, measure distance in tabbable space\n  previousTabbableIndex - currentTabbableIndex :\n  // or else measure in focusable space\n  previousFocusableIndex - currentFocusableIndex;\n  // old focus\n  if (!indexDiff && lastNodeInside >= 0) {\n    return lastNodeInside;\n  }\n  // no tabbable elements, autofocus is not possible\n  if (innerTabbables.length === 0) {\n    // an edge case with no tabbable elements\n    // return the last focusable one\n    // with some probability this will prevent focus from cycling across the lock, but there is no tabbale elements to cycle to\n    return lastNodeInside;\n  }\n  var returnFirstNode = pickFocusable(innerNodes, innerTabbables[0]);\n  var returnLastNode = pickFocusable(innerNodes, innerTabbables[innerTabbables.length - 1]);\n  // first element\n  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n    return returnLastNode;\n  }\n  // last element\n  if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n    return returnFirstNode;\n  }\n  // jump out, but not on the guard\n  if (indexDiff && Math.abs(focusIndexDiff) > 1) {\n    return lastNodeInside;\n  }\n  // focus above lock\n  if (activeIndex <= firstNodeIndex) {\n    return returnLastNode;\n  }\n  // focus below lock\n  if (activeIndex > lastNodeIndex) {\n    return returnFirstNode;\n  }\n  // index is inside tab order, but outside Lock\n  if (indexDiff) {\n    if (Math.abs(indexDiff) > 1) {\n      return lastNodeInside;\n    }\n    return (cnt + lastNodeInside + indexDiff) % cnt;\n  }\n  // do nothing\n  return undefined;\n};","map":{"version":3,"names":["correctNodes","pickFocusable","isGuard","NEW_FOCUS","newFocus","innerNodes","innerTabbables","outerNodes","activeElement","lastNode","cnt","length","firstFocus","lastFocus","isOnGuard","indexOf","undefined","activeIndex","lastIndex","lastNodeInside","indexDiff","firstNodeIndex","lastNodeIndex","correctedNodes","currentFocusableIndex","previousFocusableIndex","tabbableNodes","filter","node","tabIndex","currentTabbableIndex","previousTabbableIndex","focusIndexDiff","returnFirstNode","returnLastNode","Math","abs"],"sources":["/home/coder/project/reactlab/node_modules/focus-lock/dist/es2015/solver.js"],"sourcesContent":["import { correctNodes } from './utils/correctFocus';\nimport { pickFocusable } from './utils/firstFocus';\nimport { isGuard } from './utils/is';\nexport var NEW_FOCUS = 'NEW_FOCUS';\n/**\n * Main solver for the \"find next focus\" question\n * @param innerNodes - used to control \"return focus\"\n * @param innerTabbables - used to control \"autofocus\"\n * @param outerNodes\n * @param activeElement\n * @param lastNode\n * @returns {number|string|undefined|*}\n */\nexport var newFocus = function (innerNodes, innerTabbables, outerNodes, activeElement, lastNode) {\n    var cnt = innerNodes.length;\n    var firstFocus = innerNodes[0];\n    var lastFocus = innerNodes[cnt - 1];\n    var isOnGuard = isGuard(activeElement);\n    // focus is inside\n    if (activeElement && innerNodes.indexOf(activeElement) >= 0) {\n        return undefined;\n    }\n    var activeIndex = activeElement !== undefined ? outerNodes.indexOf(activeElement) : -1;\n    var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;\n    var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;\n    // no active focus (or focus is on the body)\n    if (activeIndex === -1) {\n        // known fallback\n        if (lastNodeInside !== -1) {\n            return lastNodeInside;\n        }\n        return NEW_FOCUS;\n    }\n    // new focus, nothing to calculate\n    if (lastNodeInside === -1) {\n        return NEW_FOCUS;\n    }\n    var indexDiff = activeIndex - lastIndex;\n    var firstNodeIndex = outerNodes.indexOf(firstFocus);\n    var lastNodeIndex = outerNodes.indexOf(lastFocus);\n    var correctedNodes = correctNodes(outerNodes);\n    var currentFocusableIndex = activeElement !== undefined ? correctedNodes.indexOf(activeElement) : -1;\n    var previousFocusableIndex = lastNode ? correctedNodes.indexOf(lastNode) : currentFocusableIndex;\n    var tabbableNodes = correctedNodes.filter(function (node) { return node.tabIndex >= 0; });\n    var currentTabbableIndex = activeElement !== undefined ? tabbableNodes.indexOf(activeElement) : -1;\n    var previousTabbableIndex = lastNode ? tabbableNodes.indexOf(lastNode) : currentTabbableIndex;\n    var focusIndexDiff = currentTabbableIndex >= 0 && previousTabbableIndex >= 0\n        ? // old/new are tabbables, measure distance in tabbable space\n            previousTabbableIndex - currentTabbableIndex\n        : // or else measure in focusable space\n            previousFocusableIndex - currentFocusableIndex;\n    // old focus\n    if (!indexDiff && lastNodeInside >= 0) {\n        return lastNodeInside;\n    }\n    // no tabbable elements, autofocus is not possible\n    if (innerTabbables.length === 0) {\n        // an edge case with no tabbable elements\n        // return the last focusable one\n        // with some probability this will prevent focus from cycling across the lock, but there is no tabbale elements to cycle to\n        return lastNodeInside;\n    }\n    var returnFirstNode = pickFocusable(innerNodes, innerTabbables[0]);\n    var returnLastNode = pickFocusable(innerNodes, innerTabbables[innerTabbables.length - 1]);\n    // first element\n    if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n        return returnLastNode;\n    }\n    // last element\n    if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n        return returnFirstNode;\n    }\n    // jump out, but not on the guard\n    if (indexDiff && Math.abs(focusIndexDiff) > 1) {\n        return lastNodeInside;\n    }\n    // focus above lock\n    if (activeIndex <= firstNodeIndex) {\n        return returnLastNode;\n    }\n    // focus below lock\n    if (activeIndex > lastNodeIndex) {\n        return returnFirstNode;\n    }\n    // index is inside tab order, but outside Lock\n    if (indexDiff) {\n        if (Math.abs(indexDiff) > 1) {\n            return lastNodeInside;\n        }\n        return (cnt + lastNodeInside + indexDiff) % cnt;\n    }\n    // do nothing\n    return undefined;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}